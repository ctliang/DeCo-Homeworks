//----------------- Future Contract Box Registers------------------
   // R4[Boolean]: funded
    // R5[int]: expiryHeight
    // R6(0)[long]: jobID
    // R6(1)[long]: exRate
    // R6(2)[long]: amountProv
    // R6(3)[long]: amountNeed - set by Opener (T1)
    // R7(0)[Coll[Byte]]: tokenID1
    // R7(1)[Coll[Byte]]: openerPK
    // R7(2)[Coll[Byte]]: funderPK
    //-----------------
    // hard coded values (see off-chain code)
    // _miningFee - Parameters.Minfee
    // _ergInNanoErg - Parameters.OneErg
//----------------- Future Contract Box Registers------------------

// ----------------------------------------
// expiration transaction 
// ----------------------------------------
    if(INPUTS.size == 1 && (HEIGHT > SELF.R5[Int].get)){

        val funded: Boolean         = SELF.R4[Boolean].get
        val expiryInFCB: Int        = SELF.R5[Int].get

        val xrateInFCB: Long        = SELF.R6[Coll[Long]].get(1)
        val amountProvInFCB: Long   = SELF.R6[Coll[Long]].get(2) //in nanoErg
        val amountNeededInFCB: Long = SELF.R6[Coll[Long]].get(3) // in SigUSD

        val tokenID1InFCB: Coll[Byte] = SELF.R7[Coll[Coll[Byte]]].get(0)
        val openerpkInFCB: Coll[Byte] = SELF.R7[Coll[Coll[Byte]]].get(1)
        val funderpkInFCB: Coll[Byte] = SELF.R7[Coll[Coll[Byte]]].get(2)

        val OpenerBox: Box              = OUTPUTS(0)

    // ---------------------payout boolean-------------------
    // INPUTS:	FCB	---> OUTPUTS:	T1	T2	Fee
    //------------------------------------------------------
        val payout: Boolean = allOf(Coll(
            funded,

        // all tokens in FCB are sent to Openerpk
            OpenerBox.propositionBytes == openerpkInFCB, //OUTPUT(0)
            OpenerBox.tokens(0)._1 == tokenID1InFCB, // in sigUSD
            OpenerBox.tokens(0)._2 == SELF.tokens(0)._2,

        // Erg is sent to funder, but calculated from sigUSD amount Needed value and exchangerate
            OUTPUTS(1).propositionBytes == funderpkInFCB,

        // calculate ERG for T2 = tokens in FCB / exchange rate * nanoERG
        // in nanoErgs
            OUTPUTS(1).value == SELF.tokens(0)._2 / xrateInFCB * _ergInNanoErg,
        //Q: can use SELF.tokens(0)._2.get twice?

        // limit output size, as all remaining erg should be sent to T1 (OpenerBox)
        // to prevent them from being stolen
            OUTPUTS.size == 3 //
        ))
    // -------------------------refund boolean ---------------
    // INPUTS:	FCB	---> OUTPUTS:	T1	Fee
        //------------------------------------------------------
        val refund: Boolean = allOf(Coll(
            funded == false,

        // FCB should have no tokens, all ERG - Fee sent to OpenerBox
            OpenerBox.propositionBytes == openerpkInFCB,
            OpenerBox.value == SELF.value - _miningFee
        ))
        sigmaProp(anyOf(Coll(
            refund,
            payout
        )))
    }
    else
    {
      if(INPUTS.size == 2){
      // ---------------------funding existing FCB-------------------
      // INPUTS:	FCB	T2 ---> OUTPUTS: FCB (T2)*	Fee *if there is change
      // ----------------------------------------

      //setting futureContractBox val
      val futureContractBox: Box = OUTPUTS(0)

      // --- jobID & these registers should stay the same
       // R5[int]: expiryHeight
          // R6(0)[long]: jobID
          // R6(1)[long]: exRate
          // R6(2)[long]: amountProv
          // R6(3)[long]: amountNeed
          // R7(0)[Coll[Byte]]: tokenID1
          // R7(1)[Coll[Byte]]: openerPK
      val FCBOutputCheck: Boolean = allOf(Coll(
        futureContractBox.propositionBytes == SELF.propositionBytes,
        SELF.R5[Int].get == futureContractBox.R5[Int].get,
        SELF.R6[Coll[Long]].get == futureContractBox.R6[Coll[Long]].get,
        SELF.R7[Coll[Coll[Byte]]].get(0) == futureContractBox.R7[Coll[Coll[Byte]]].get(0),
        SELF.R7[Coll[Coll[Byte]]].get(1) == futureContractBox.R7[Coll[Coll[Byte]]].get(1)
      ))

      // increase FCB output (0) by miningFee for payout tx
      val FCBvalueCheck: Boolean = (futureContractBox.value == SELF.value + _miningFee)

      // T2 funder box is
      val userBox1: Box = INPUTS(1)
      val funderpk: Coll[Byte] = userBox1.propositionBytes

      // updating FCB registers
      val setFundInfo: Boolean = allOf(Coll(
        futureContractBox.R4[Boolean].get == true,
        futureContractBox.R7[Coll[Coll[Byte]]].get(2) == funderpk
      ))

      // get funding info: tokenID and max amount
      val requestedTokenID = SELF.R7[Coll[Coll[Byte]]].get(0)
      val tokenAmountNeeded = SELF.R6[Coll[Long]].get(3)

      //check if funder has correct tokens
      val funderHasTokensCheck: Boolean = userBox1.tokens(0)._1 == requestedTokenID

      // check if only partial fund
      val partialfund: Boolean = allOf(Coll(
        userBox1.tokens(0)._2 < tokenAmountNeeded,
        futureContractBox.tokens(0)._2 == userBox1.tokens(0)._2,
        futureContractBox.tokens(0)._1 == requestedTokenID,
        OUTPUTS.size == 2
        ))

      // funder has more tokens, fully fund it (return rest)
      val fullyfunded: Boolean = allOf(Coll(
        futureContractBox.tokens(0)._2 == tokenAmountNeeded,
        futureContractBox.tokens(0)._1 == requestedTokenID,
        OUTPUTS(2).value == _miningFee,
        OUTPUTS(2).propositionBytes == funderpk,
        OUTPUTS.size == 3

      ))
      sigmaProp(allOf(Coll(
        FCBOutputCheck,
        FCBvalueCheck,
        setFundInfo,
        funderHasTokensCheck,
        anyOf(Coll(
            partialfund,
            fullyfunded
        ))
    )))
      }
      else {sigmaProp(false)}
    }
